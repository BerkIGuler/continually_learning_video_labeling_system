Index: anno/annotation_temp.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import copy\r\nimport os\r\nimport cv2\r\n\r\n# class Dictionary\r\nclassDict = {\"1\": \"Car\", \"7\": \"Person\", \"24\": \"Apartment\", \"31\": \"Cloud\", \"32\": \"Forest\"}\r\n\r\nzoom_level = 0.1\r\nzoom_step = 0.1\r\ncenter = None\r\n\r\n# To write x and y values & classes\r\nframe_list = []\r\nframe_list_classes = []\r\n\r\n# To show added labels frame\r\ndisplay_frame = \"\"\r\ndrawing = False\r\nix, iy = 0, 0\r\n\r\n# To save desired deleting labels\r\ndesired_deletes = []\r\n\r\n# To change class name\r\ndesired_change_name = []\r\ndesired_change_point = []\r\n\r\npressed = False\r\ncache = None\r\n\r\ndef mouse_click(event, x, y, flags, param):\r\n    global frame_list, frame_list_classes, display_frame, drawing, ix, iy,\\\r\n        desired_deletes, desired_change_name, zoom_level, zoom_step, pressed, cache, classDict\r\n\r\n    # Check if you started to hold left click\r\n    if event == cv2.EVENT_LBUTTONDOWN:\r\n        print(\"Left start: \", x, y)\r\n        ix, iy = x, y\r\n        pressed = True\r\n        cache = copy.deepcopy(display_frame)\r\n\r\n    if event == cv2.EVENT_MOUSEMOVE and pressed:\r\n        cv2.rectangle(cache, (ix, iy), (x, y), (0, 0, 255), 2)\r\n        cv2.imshow(\"window\", cache)\r\n        cache = copy.deepcopy(display_frame)\r\n    # Check if you finished holding left click\r\n    if event == cv2.EVENT_LBUTTONUP:\r\n        print(\"Left release: \", x, y)\r\n        frame_list.append([ix, iy, x, y])\r\n        pressed = False\r\n\r\n        # Get the class with keyboard\r\n        key = cv2.waitKey(0)\r\n        if key == ord(\"1\"):\r\n            frame_list_classes.append(\"7\") # Person\r\n        elif key == ord(\"2\"):\r\n            frame_list_classes.append(\"1\") # Car\r\n        elif key == ord(\"3\"):\r\n            frame_list_classes.append(\"24\") # Apartment\r\n        elif key == ord(\"4\"):\r\n            frame_list_classes.append(\"32\") # Forest\r\n        elif key == ord(\"5\"):\r\n            frame_list_classes.append(\"31\")  # Cloud\r\n\r\n        # Draw bounding box\r\n        cv2.rectangle(display_frame, (ix, iy), (x, y), (0, 0, 255), 2)\r\n        cv2.putText(\r\n            display_frame, classDict[frame_list_classes[-1]], (ix, iy - 5),\r\n            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1,\r\n            cv2.LINE_4)\r\n\r\n        cv2.imshow(\"window\", display_frame)\r\n\r\n    # When right clicked\r\n    if event == cv2.EVENT_RBUTTONDOWN:\r\n        print(\"Right clicked: \", x, y)\r\n        desired_deletes.append((x, y))\r\n\r\n    # If middle button is clicked\r\n    if event == cv2.EVENT_MBUTTONDOWN:\r\n        print(\"Middle pressed: \", x, y)\r\n        desired_change_point.append((x, y))\r\n\r\n        # Get desired class name\r\n        key = cv2.waitKey(0)\r\n        if key == ord(\"1\"):\r\n            frame_list_classes.append(\"7\") # Person\r\n        elif key == ord(\"2\"):\r\n            frame_list_classes.append(\"1\") # Car\r\n        elif key == ord(\"3\"):\r\n            frame_list_classes.append(\"24\") # Apartment\r\n        elif key == ord(\"4\"):\r\n            frame_list_classes.append(\"32\") # Forest\r\n        elif key == ord(\"5\"):\r\n            frame_list_classes.append(\"31\")  # Cloud\r\n\r\n    if event == cv2.EVENT_MOUSEWHEEL:\r\n        print(\"Mouse wheel touched\")\r\n        # If the mouse scroll is moved up, zoom in\r\n        if flags > 0:\r\n            print((x, y))\r\n            zoom_level += zoom_step\r\n            print(zoom_level)\r\n            display_frame = cv2.resize(\r\n                display_frame, None, fx=zoom_level,\r\n                fy=zoom_level, interpolation=cv2.INTER_LINEAR)\r\n            cv2.imshow(\"window\", display_frame)\r\n        # If the mouse scroll is moved down, zoom out\r\n        elif flags < 0:\r\n            print((x, y))\r\n            zoom_level -= zoom_step\r\n            print(zoom_level)\r\n            display_frame = cv2.resize(\r\n                display_frame, None, fx=zoom_level,\r\n                fy=zoom_level, interpolation=cv2.INTER_LINEAR)\r\n\r\n            # Get the new size of the image\r\n            # rows, cols, _ = display_frame.shape\r\n            # Get the new center of the image\r\n            # new_center = (x,y)\r\n            # Calculate the translation to keep the center at the same position\r\n            # Middle = np.float32([[1, 0, new_center[0] - center[0]], [0, 1, new_center[1] - center[1]]])\r\n            # display_frame = cv2.warpAffine(display_frame, new_center, (cols, rows))\r\n\r\n            cv2.imshow(\"window\", display_frame)\r\n\r\n\r\n\r\ndef update_labels(vid_name, frame_num, labels_path, x_size, y_size):\r\n    global frame_list, frame_list_classes\r\n\r\n    # If there is already labeled info, append\r\n    if os.path.exists(\"{}/{}_{}.txt\".format(labels_path, vid_name, frame_num)):\r\n        file = open(\"{}/{}_{}.txt\".format(labels_path, vid_name, frame_num), \"a\")\r\n        cnt = 0\r\n        for i in range(0, len(frame_list)):\r\n            centerPointx = (frame_list[i][0] + frame_list[i][2]) / 2 / x_size\r\n            centerPointy = (frame_list[i][1] + frame_list[i][3]) / 2 / y_size\r\n            width = abs(frame_list[i][0] - frame_list[i][2]) / x_size\r\n            height = abs(frame_list[i][1] - frame_list[i][3]) / y_size\r\n            file.write(frame_list_classes[cnt] + \" \")\r\n            file.write(\"{:.6f}\".format(centerPointx) + \" \")\r\n            file.write(\"{:.6f}\".format(centerPointy) + \" \")\r\n            file.write(\"{:.6f}\".format(width) + \" \")\r\n            file.write(\"{:.6f}\".format(height) + \"\\n\")\r\n            cnt += 1\r\n\r\n    # If there is not any label yet, create and write\r\n    else:\r\n        file = open(\"{}/{}_{}.txt\".format(labels_path, vid_name, frame_num), \"w\")\r\n        cnt = 0\r\n        for i in range(0, len(frame_list)):\r\n            centerPointx = (frame_list[i][0] + frame_list[i][2]) / 2 / x_size\r\n            centerPointy = (frame_list[i][1] + frame_list[i][3]) / 2 / y_size\r\n            width = abs(frame_list[i][0] - frame_list[i][2]) / x_size\r\n            height = abs(frame_list[i][1] - frame_list[i][3]) / y_size\r\n            file.write(frame_list_classes[cnt] + \" \")\r\n            file.write(\"{:.6f}\".format(centerPointx) + \" \")\r\n            file.write(\"{:.6f}\".format(centerPointy) + \" \")\r\n            file.write(\"{:.6f}\".format(width) + \" \")\r\n            file.write(\"{:.6f}\".format(height) + \"\\n\")\r\n            cnt += 1\r\n\r\n    # Make frame_list ready for next annotations\r\n    frame_list = []\r\n    frame_list_classes = []\r\n\r\n\r\ndef save_annotated_frames(vid_name, anno_frame, frame_num, anno_frames_path):\r\n    cv2.imwrite(\"{}/{}_{}.jpg\".format(anno_frames_path, vid_name, frame_num), anno_frame)\r\n\r\n\r\ndef delete_labels(vid_name, frame_num, labels_path):\r\n    global desired_deletes\r\n\r\n    lines_list = []\r\n    removal_list = []\r\n\r\n    # Open file to read\r\n    f1 = open(\"{}/{}_{}.txt\".format(labels_path, vid_name, frame_num), \"r\")\r\n\r\n    # Get lines\r\n    for line in f1:\r\n        lines_list.append(line)\r\n\r\n    # Get indices where point is inside any label\r\n    cnt = 0\r\n    for i in range(len(lines_list)):\r\n        values = lines_list[i].split(\"\\t\")\r\n        x1, y1, x2, y2 = int(values[1]), int(values[2]), int(values[3]), int(values[4])\r\n        for point in desired_deletes:\r\n            xp, yp = int(point[0]), int(point[1])\r\n            if max(x1, x2) > xp > min(x1, x2) and max(y1, y2) > yp > min(y1, y2):\r\n                if cnt not in removal_list:\r\n                    removal_list.append(cnt)\r\n        cnt += 1\r\n\r\n    # Open file to write\r\n    f2 = open(\"{}/{}_{}.txt\".format(labels_path, vid_name, frame_num), \"w\")\r\n\r\n    for i in range(len(lines_list)):\r\n        if i not in removal_list:\r\n            f2.write(lines_list[i])\r\n\r\n    # Prepare desired_deletes for next frames\r\n    desired_deletes = []\r\n\r\n\r\ndef change_class_name(vid_name, frame_num, labels_path):\r\n    global desired_change_name, desired_change_point\r\n\r\n    lines_list = []\r\n    changed_line_list = []\r\n\r\n    # Open file\r\n    f1 = open(\"{}/{}_{}.txt\".format(labels_path, vid_name, frame_num), \"r\")\r\n\r\n    # Get lines\r\n    for line in f1:\r\n        lines_list.append(line)\r\n        changed_line_list.append(line)\r\n\r\n    # Get indices where point is inside any label\r\n    cnt = 0\r\n    for i in range(len(lines_list)):\r\n        values = lines_list[i].split(\"\\t\")\r\n        x1, y1, x2, y2 = int(values[1]), int(values[2]), int(values[3]), int(values[4])\r\n        cnt_p = 0\r\n        for point in desired_change_point:\r\n            xp, yp = int(point[0]), int(point[1])\r\n            if max(x1, x2) > xp > min(x1, x2) and max(y1, y2) > yp > min(y1, y2):\r\n                new_class = desired_change_name[cnt_p]\r\n                new_line = new_class + \"\\t\" + str(x1) + \"\\t\" + str(y1) + \"\\t\" + str(x2) + \"\\t\" + str(y2) + \"\\n\"\r\n                changed_line_list.pop(cnt)\r\n                changed_line_list.insert(cnt, new_line)\r\n                break\r\n            cnt_p += 1\r\n\r\n        cnt += 1\r\n\r\n    # Open file to write\r\n    f2 = open(\"{}/{}_{}.txt\".format(labels_path, vid_name, frame_num), \"w\")\r\n\r\n    for line in changed_line_list:\r\n        f2.write(line)\r\n\r\n    # Prepare them for next frames\r\n    desired_change_name = []\r\n    desired_change_point = []\r\n\r\n\r\ndef annotation_from_local_video(\r\n        video_path, fps, x_size, y_size,\r\n        frames_path, labels_path, annotated_frames_path):\r\n    global frame_list, display_frame, desired_deletes, desired_change_name, zoom_level, zoom_step\r\n    # Zoom level and step size for each scroll\r\n    zoom_level = 1\r\n    zoom_step = 0.1\r\n\r\n    # Capture Video\r\n    captured = cv2.VideoCapture(video_path)\r\n    video_name = os.path.basename(video_path).split(\".\")[0]\r\n\r\n    frame_num = 0\r\n    while True:\r\n        # Capture frame-by-frame\r\n        ret, frame = captured.read()\r\n        frame = cv2.resize(frame, (x_size, y_size))\r\n        display_frame = frame\r\n        # Get the size of the image\r\n        rows, cols, _ = display_frame.shape\r\n        # Get the center of the image\r\n        center = (cols // 2, rows // 2)\r\n        # Display the resulting frame\r\n        cv2.imshow(\"window\", frame)\r\n\r\n        # !!! Save raw frames\r\n        # cv2.imwrite(\"{}/{}.jpg\".format(frames_path, frame_num), frame)\r\n        print(frame_num)\r\n\r\n        key = cv2.waitKey(fps)  # fps variable is actually states the delay in milliseconds\r\n\r\n        # Stop video if \"q\" pressed\r\n        if key & 0xFF == ord(\"q\"):\r\n            break\r\n\r\n        if key & 0xFF == ord(\"a\"):\r\n            print(\"Annotation Mode opened, video paused!\")\r\n            cv2.setMouseCallback('window', mouse_click)\r\n            key = cv2.waitKey(0) & 0xFF\r\n            cv2.setMouseCallback('window', mouse_click)\r\n            # Setting zoom level and step size to their original values\r\n            zoom_level = 1\r\n            zoom_step = 0.1\r\n\r\n            # Update Labels if you get any x and y values\r\n            if len(frame_list) != 0:\r\n                print(\"Saving annotated frames\")\r\n                save_annotated_frames(video_name, display_frame, frame_num, annotated_frames_path)\r\n                print(\"Saving labels of annotated frames\")\r\n                update_labels(video_name, frame_num, labels_path, x_size, y_size)\r\n\r\n            # If right is clicked and it is desired to delete some labels\r\n            if len(desired_deletes) > 0:\r\n                print(\"Deleting desired labels\")\r\n                delete_labels(video_name, frame_num, labels_path)\r\n\r\n            if len(desired_change_name) > 0:\r\n                print(\"Changing class names of desired labels\")\r\n                change_class_name(video_name, frame_num, labels_path)\r\n\r\n        frame_num += 1\r\n\r\n    # When everything done, release the capture\r\n    captured.release()\r\n    cv2.destroyAllWindows()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/anno/annotation_temp.py b/anno/annotation_temp.py
--- a/anno/annotation_temp.py	(revision 26735c9014f78040eadf8f673a94615350bbd158)
+++ b/anno/annotation_temp.py	(date 1675189164621)
@@ -52,13 +52,13 @@
         # Get the class with keyboard
         key = cv2.waitKey(0)
         if key == ord("1"):
-            frame_list_classes.append("7") # Person
+            frame_list_classes.append("7")  # Person
         elif key == ord("2"):
-            frame_list_classes.append("1") # Car
+            frame_list_classes.append("1")  # Car
         elif key == ord("3"):
-            frame_list_classes.append("24") # Apartment
+            frame_list_classes.append("24")  # Apartment
         elif key == ord("4"):
-            frame_list_classes.append("32") # Forest
+            frame_list_classes.append("32")  # Forest
         elif key == ord("5"):
             frame_list_classes.append("31")  # Cloud
 
